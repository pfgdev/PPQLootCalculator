<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

<script>
(function ($) {
    const scalingFactor = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scaling-factor'));

    function applyTransforms(coords) {
        $('.wheel > div').each(function (i) {
            var angle = -(coords.y / 2) + (360 / 10) * i;
            $(this).css('transform', `perspective(${500 * scalingFactor}px) rotate3d(1, 0, 0, ${angle}deg) translate3d(0, 0, ${122 * scalingFactor}px)`);
        });
    }

    function calculateSegment(angle) {
        const segmentCount = 10;
        const segmentAngle = 360 / segmentCount;
        const offset = segmentAngle / 2; // Adjust this value to fine-tune alignment
        let adjustedAngle = (angle + offset) % 360;
        if (adjustedAngle < 0) {
            adjustedAngle += 360;
        }
        return Math.floor(adjustedAngle / segmentAngle);
    }

    var current_coords = { x: 0, y: 0 };
    var velocity = { x: 0, y: 0 };
    var inertia_time = null;
    var isSpinning = false;
    var initialFrameIgnored = false; // Flag to ignore the first frame
    var lastSegment = null; // Initialize lastSegment
    var lastBoundaryStartSegment = null;
    var lastBoundaryEndSegment = null;
    var hiddenTime = null; // Time when the tab was hidden
    let boundaryStartPoint = null;
    let boundaryEndPoint = null;
    let isAnimatingBackwards = false;
    let inBoundary = false; // New flag to track if we're within a boundary


    // Adjust these variables to control speed and friction
    const initialVelocityRange = [1, 2]; // Lower initial velocity
    const frictionCoefficient = 1; // Lower friction coefficient
    const mass = 1500; // Higher mass for slower deceleration

    const boundaryStartOffset = 3; // Adjust this value as needed
    const boundaryEndOffset = -3.5; // Adjust this value as needed









    function triggerFlipperAnimation(coords) {
    const boundaryStartSegment = calculateSegment((coords.y + boundaryStartOffset) / 2);
    const boundaryEndSegment = calculateSegment((coords.y + boundaryEndOffset) / 2);

    if (lastSegment === null) {
        lastSegment = boundaryStartSegment; // Set lastSegment initially
        lastBoundaryStartSegment = boundaryStartSegment;
        lastBoundaryEndSegment = boundaryEndSegment;
        console.log('Initial segment setup');
        return;
    }
    if (!initialFrameIgnored) {
        initialFrameIgnored = true; // Ignore the first frame
        console.log('Ignoring initial frame');
        return;
    }

    // Check if entering a new boundary
    if (!inBoundary && boundaryStartSegment !== lastBoundaryStartSegment) {
        inBoundary = true; // Mark as within boundary
        lastBoundaryStartSegment = boundaryStartSegment;

        // Calculate the start point of the boundary
        boundaryStartPoint = coords.y;
        // Calculate the end point of the boundary
        boundaryEndPoint = boundaryStartPoint + Math.abs(boundaryEndOffset - boundaryStartOffset);

        // Reset flipper angle to ensure it starts fresh for the new segment
        $('.flipper').css({
            'transform': 'translate(-50%, -50%) rotate(0deg)',
            'transition': 'none'
        });

        console.log(`Entered boundary at ${coords.y}`);
        console.log(`Calculated Boundary Start Point: ${boundaryStartPoint}, Calculated Boundary End Point: ${boundaryEndPoint}`);
        isAnimatingBackwards = false;
    }

    // Check if exiting the boundary
    if (inBoundary && coords.y >= boundaryEndPoint) {
        inBoundary = false; // Mark as outside boundary
        lastBoundaryEndSegment = boundaryEndSegment;
        // Ensure the flipper moves to max angle when exiting the boundary
        $('.flipper').css({
            'transform': 'translate(-50%, -50%) rotate(30deg)',
            'transition': 'none'
        });
        console.log('Flipper set to 30deg at boundary exit');

        // Start smooth transition back to 0 degrees
        setTimeout(() => {
            $('.flipper').css({
                'transform': 'translate(-50%, -50%) rotate(0deg)',
                'transition': 'transform 0.1s ease-out'
            });
            console.log('Flipper smoothly transitioning back to 0deg');
        }, 50); // Short delay to ensure the 30deg set completes before starting the transition

        isAnimatingBackwards = true;
        console.log(`Exited boundary at ${coords.y}`);
    }

    // New flipper rotation logic within the boundary
    if (inBoundary && !isAnimatingBackwards) {
        const distanceFromEndPoint = Math.abs(coords.y - boundaryEndPoint);
        const boundaryRange = boundaryEndPoint - boundaryStartPoint;
        const normalizedPosition = Math.max(0, Math.min(1, distanceFromEndPoint / boundaryRange));
        const desiredFlipperAngle = 30 * (1 - normalizedPosition); // 0 degrees at max distance, 30 degrees at zero distance

        // Set the flipper angle directly
        $('.flipper').css({
            'transform': `translate(-50%, -50%) rotate(${desiredFlipperAngle}deg)`,
            'transition': 'none'
        });

        // Log the details of the calculation
        console.log(`Boundary Start Point: ${boundaryStartPoint}`);
        console.log(`Current Position: ${coords.y}`);
        console.log(`Boundary End Point: ${boundaryEndPoint}`);
        console.log(`Remaining Position: ${distanceFromEndPoint}`);
        console.log(`Normalized Position within boundary: ${(1 - normalizedPosition) * 100}%`);
        console.log(`Desired Flipper Angle: ${desiredFlipperAngle}deg`);
    }

    // Reset boundary points when exiting the boundary
    if (!inBoundary) {
        boundaryStartPoint = null;
        boundaryEndPoint = null;
        console.log('Reset boundary points');
    }
}







    $.fn.momentus = function (cfg) {
        var now = Date.now || function () { return (new Date()).valueOf() },
            last_time = now(),

            // Configuration
            mass = cfg.mass || mass,
            u = cfg.u || frictionCoefficient,
            wheel_ratio = cfg.wheelRatio || 1000,
            on_change = cfg.onChange || function () { },
            frame_rate = cfg.frameRate || 60;

        function calculateVelocity(delta_time) {
            var vel_y = velocity.y - (u * (velocity.y / mass) * delta_time);
            return { x: 0, y: vel_y };
        }

        function inertia() {
            if (!isSpinning) {
                return;
            }

            velocity.x = !isNaN(velocity.x) ? velocity.x : 0;
            velocity.y = !isNaN(velocity.y) ? velocity.y : 0;

            if (!inertia_time) {
                inertia_time = now();
            } else if (velocity.y != 0) {
                var time = now(),
                    delta_time = time - inertia_time,
                    new_velocity = calculateVelocity(delta_time);

                velocity.y = new_velocity.y;

                var delta_y = velocity.y * delta_time;
                current_coords.y += delta_y;
                inertia_time = time;
                on_change(current_coords, velocity);

                // Trigger flipper animation based on wheel position
                triggerFlipperAnimation(current_coords);

                // If velocity is very low, consider the wheel stopped
                if (Math.abs(velocity.y) < 0.01) {
                    isSpinning = false;
                    const finalAngle = current_coords.y / 2;
                    const segment = calculateSegment(finalAngle);
                    console.log('Final Segment:', segment);

                    // Log the corresponding div
                    const selectedDiv = $(`.wheel > div[data-index="${segment}"]`);
                    const imgSrc = selectedDiv.find('img').attr('src');
                    const number = selectedDiv.find('.icon-number').text();
                    console.log(`Selected Div Index: ${segment}, Image: ${imgSrc}, Number: ${number}`);

                    $('#spinButton').prop('disabled', false); // Enable the spin button

                    return; // Exit the loop when the wheel stops
                }
            }

            if (isSpinning) {
                if (window.requestAnimationFrame) {
                    requestAnimationFrame(inertia);
                } else {
                    setTimeout(inertia, 1000 / frame_rate);
                }
            }
        }

        return {
            startSpin: function () {
                isSpinning = true;
                initialFrameIgnored = false; // Reset the flag
                lastSegment = null; // Reset lastSegment
                inertia_time = now();
                inertia();
            }
        };
    }

    $(document).ready(function () {
        applyTransforms(current_coords);
        const momentusInstance = $('.wheel').momentus({
            u: frictionCoefficient,
            mass: mass,
            wheelRatio: -1000,
            onChange: function (coords, velocity) {
                applyTransforms(coords);
            }
        });

        $('#spinButton').on('click', function () {
            if (isSpinning) return;
            isSpinning = true;
            $('#spinButton').prop('disabled', true); // Disable the spin button
            let initialVelocity = Math.random() * (initialVelocityRange[1] - initialVelocityRange[0]) + initialVelocityRange[0]; // Updated initial velocity function
            velocity.y = initialVelocity;
            inertia_time = Date.now();
            momentusInstance.startSpin(); // Call the inertia function correctly
        });

        document.addEventListener('visibilitychange', function () {
            if (document.hidden) {
                hiddenTime = Date.now();
            } else {
                if (hiddenTime) {
                    const elapsed = Date.now() - hiddenTime;
                    inertia_time += elapsed; // Adjust inertia time by the elapsed hidden time
                    hiddenTime = null;
                }
            }
        });
    });

})(jQuery);
</script>
