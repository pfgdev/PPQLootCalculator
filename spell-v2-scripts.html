<!-- spell-v2-scripts.html -->
<script>
  (function () {
    let root;
    let listBodyA;
    let listBodyB;
    let filterInput;
    let rollButton;
    let rollValueNode;
    let listLoadingNode;
    let detailLoadingNode;

    let detailTitle;
    let castTimeNode;
    let rangeNode;
    let durationNode;
    let attackSaveNode;
    let damageEffectNode;
    let componentVNode;
    let componentSNode;
    let componentMNode;
    let componentCNode;
    let materialNode;
    let descriptionNode;
    let metaLevelNode;
    let metaSchoolNode;
    let metaSourceNode;

    let currentLevel = null;
    let currentSpells = [];
    let selectedSpellIndex = null;
    let listRequestToken = 0;
    let detailRequestToken = 0;
    let isRolling = false;
    let rollTimerId = null;
    let lastRollValue = null;

    function isReRollSpell(spell) {
      const name = String((spell && spell.name) || "")
        .trim()
        .toLowerCase()
        .replace(/[\s-]/g, "");
      return name === "reroll";
    }

    function normalizeSpellRows(rawRows, level) {
      const sourceRows = Array.isArray(rawRows) ? rawRows : [];
      const baseRows = [];

      sourceRows.forEach(function (spell, sourceIndex) {
        if (!spell || isReRollSpell(spell)) return;
        const normalizedSpell = Object.assign({}, spell);
        normalizedSpell.detailIndex = sourceIndex;
        normalizedSpell.isReRoll = false;
        baseRows.push(normalizedSpell);
      });

      if (!baseRows.length) return [];

      const rangePerSpell = Math.max(1, Math.floor(100 / baseRows.length));
      const normalizedRows = baseRows.map(function (spell, visualIndex) {
        const start = visualIndex * rangePerSpell + 1;
        const end = (visualIndex + 1) * rangePerSpell;
        return Object.assign({}, spell, {
          diceRange: String(start) + "-" + String(end),
          rollStart: start,
          rollEnd: end
        });
      });

      const lastEnd = rangePerSpell * baseRows.length;
      if (lastEnd < 100) {
        const reRollStart = lastEnd + 1;
        normalizedRows.push({
          diceRange: String(reRollStart) + "-100",
          name: "Re-Roll",
          level: level,
          isReRoll: true,
          rollStart: reRollStart,
          rollEnd: 100,
          detailIndex: -1
        });
      }

      return normalizedRows;
    }

    function toBool(value) {
      if (typeof value === "boolean") return value;
      if (typeof value === "number") return value !== 0;
      if (typeof value === "string") {
        const normalized = value.trim().toLowerCase();
        return normalized === "true" || normalized === "1" || normalized === "yes" || normalized === "y";
      }
      return false;
    }

    function setListLoading(isLoading) {
      if (listLoadingNode) {
        listLoadingNode.hidden = !isLoading;
      }
    }

    function setDetailLoading(isLoading) {
      if (detailLoadingNode) {
        detailLoadingNode.hidden = !isLoading;
      }
    }

    function toggleDetailPanel(show) {
      if (root) {
        root.classList.toggle("spell-v2-has-detail", !!show);
      }
    }

    function setLevelSelection(level) {
      root.querySelectorAll('[data-action="pick-level"]').forEach(function (button) {
        button.classList.toggle("is-selected", Number(button.getAttribute("data-level")) === level);
      });
    }

    function clearTBody(tbody) {
      while (tbody.firstChild) tbody.removeChild(tbody.firstChild);
    }

    function addEmptyRow(tbody, message) {
      const row = document.createElement("tr");
      const cell = document.createElement("td");
      cell.colSpan = 2;
      cell.className = "spell-v2-empty";
      cell.textContent = message;
      row.appendChild(cell);
      tbody.appendChild(row);
    }

    function getFilteredRows() {
      const term = filterInput.value.trim().toLowerCase();
      return currentSpells
        .map(function (spell, index) { return { spell: spell, index: index }; })
        .filter(function (item) {
          return !term || (item.spell.name || "").toLowerCase().indexOf(term) !== -1;
        });
    }

    function randomD100() {
      return Math.floor(Math.random() * 100) + 1;
    }

    function findSpellIndexByRollValue(rollValue) {
      const roll = Number(rollValue);
      if (!Number.isFinite(roll)) return -1;
      for (let i = 0; i < currentSpells.length; i += 1) {
        const spell = currentSpells[i];
        const start = Number(spell.rollStart);
        const end = Number(spell.rollEnd);
        if (Number.isFinite(start) && Number.isFinite(end) && roll >= start && roll <= end) {
          return i;
        }
      }
      return -1;
    }

    function getFirstRollableIndex() {
      return currentSpells.findIndex(function (spell) {
        return spell && !spell.isReRoll;
      });
    }

    function updateRollValueDisplay(value) {
      if (!rollValueNode) return;
      rollValueNode.textContent = value === null || value === undefined ? "??" : String(value);
    }

    function scrollSpellRowIntoView(index) {
      if (!root) return;
      const listScroll = document.getElementById("spellV2ListScroll");
      if (!listScroll) return;
      const row = root.querySelector('tr[data-index="' + String(index) + '"]');
      if (!row) return;

      const hostRect = listScroll.getBoundingClientRect();
      const rowRect = row.getBoundingClientRect();
      const padding = 8;

      if (rowRect.top < hostRect.top + padding) {
        listScroll.scrollTop += rowRect.top - hostRect.top - padding;
      } else if (rowRect.bottom > hostRect.bottom - padding) {
        listScroll.scrollTop += rowRect.bottom - hostRect.bottom + padding;
      }
    }

    function setRollingState(nextRolling) {
      isRolling = !!nextRolling;
      if (root) {
        root.classList.toggle("spell-v2-is-rolling", isRolling);
      }
      if (rollButton) {
        rollButton.classList.toggle("is-rolling", isRolling);
        rollButton.disabled = isRolling;
      }
      if (filterInput) {
        filterInput.disabled = isRolling;
      }
      if (root) {
        root.querySelectorAll('[data-action="pick-level"]').forEach(function (button) {
          button.disabled = isRolling;
        });
      }
    }

    function cancelRollSequence(resetDisplay) {
      if (rollTimerId) {
        clearTimeout(rollTimerId);
        rollTimerId = null;
      }
      if (!isRolling && !resetDisplay) return;
      setRollingState(false);
      if (resetDisplay) {
        lastRollValue = null;
        updateRollValueDisplay(null);
      }
    }

    function previewRoll(rollValue) {
      lastRollValue = rollValue;
      updateRollValueDisplay(rollValue);

      const previewIndex = findSpellIndexByRollValue(rollValue);
      if (previewIndex < 0) return;
      selectedSpellIndex = previewIndex;
      renderSpellList();
      toggleDetailPanel(true);
      setDetailLoading(false);
      setDetailPlaceholders("Rolling d100...", currentSpells[previewIndex].name || "Rolling...");
    }

    function finishRoll() {
      const maxAttempts = 40;
      let attempts = 0;
      let chosenRoll = Number(lastRollValue);
      let chosenIndex = findSpellIndexByRollValue(chosenRoll);

      while (
        attempts < maxAttempts &&
        (chosenIndex < 0 || !currentSpells[chosenIndex] || currentSpells[chosenIndex].isReRoll)
      ) {
        chosenRoll = randomD100();
        chosenIndex = findSpellIndexByRollValue(chosenRoll);
        attempts += 1;
      }

      if (chosenIndex < 0 || !currentSpells[chosenIndex] || currentSpells[chosenIndex].isReRoll) {
        chosenIndex = getFirstRollableIndex();
        if (chosenIndex < 0) {
          cancelRollSequence(false);
          return;
        }
        chosenRoll = currentSpells[chosenIndex].rollStart;
      }

      setRollingState(false);
      previewRoll(chosenRoll);
      scrollSpellRowIntoView(chosenIndex);
      loadSpellDetail(chosenIndex);
    }

    function startRollSequence() {
      if (isRolling || !currentSpells.length) return;
      if (!root || !root.closest("#SpellScrollsV2") || !document.getElementById("SpellScrollsV2").classList.contains("active")) {
        return;
      }

      const hasRollableSpell = getFirstRollableIndex() >= 0;
      if (!hasRollableSpell) return;

      detailRequestToken += 1;
      setDetailLoading(false);
      if (filterInput && filterInput.value.trim()) {
        filterInput.value = "";
      }
      selectedSpellIndex = null;
      renderSpellList();
      toggleDetailPanel(true);

      setRollingState(true);
      const startedAt = Date.now();
      const rollDurationMs = 2450;

      const tick = function () {
        if (!isRolling) return;
        const spellTab = document.getElementById("SpellScrollsV2");
        if (!spellTab || !spellTab.classList.contains("active")) {
          cancelRollSequence(false);
          return;
        }

        const elapsed = Date.now() - startedAt;
        const progress = Math.min(1, elapsed / rollDurationMs);
        previewRoll(randomD100());

        if (progress >= 1) {
          finishRoll();
          return;
        }

        const nextDelay = 46 + Math.floor(progress * progress * 210);
        rollTimerId = setTimeout(tick, nextDelay);
      };

      tick();
    }

    function buildSpellRow(item) {
      const row = document.createElement("tr");
      const isReRoll = !!item.spell.isReRoll;
      row.className = "spell-v2-row"
        + (isReRoll ? " spell-v2-row-reroll" : "")
        + (item.index === selectedSpellIndex && !isReRoll ? " is-selected" : "");
      row.setAttribute("data-index", String(item.index));
      if (!isReRoll) {
        row.addEventListener("click", function (event) {
          event.stopPropagation();
          loadSpellDetail(item.index);
        });
      }

      const rangeCell = document.createElement("td");
      rangeCell.textContent = item.spell.diceRange || "--";

      const nameCell = document.createElement("td");
      const pickButton = document.createElement("button");
      pickButton.type = "button";
      pickButton.className = "spell-v2-spell-btn";
      pickButton.textContent = item.spell.name || "Unknown Spell";
      if (isReRoll) {
        pickButton.disabled = true;
        pickButton.setAttribute("aria-disabled", "true");
        pickButton.tabIndex = -1;
      } else {
        pickButton.setAttribute("data-action", "pick-spell");
      }

      nameCell.appendChild(pickButton);
      row.appendChild(rangeCell);
      row.appendChild(nameCell);
      return row;
    }

    function renderSpellList() {
      setListLoading(false);
      const rows = getFilteredRows();
      clearTBody(listBodyA);
      clearTBody(listBodyB);

      if (!rows.length) {
        addEmptyRow(listBodyA, "No spells match this filter.");
        addEmptyRow(listBodyB, "No spells match this filter.");
        return;
      }

      const splitPoint = Math.ceil(rows.length / 2);
      const firstHalf = rows.slice(0, splitPoint);
      const secondHalf = rows.slice(splitPoint);

      firstHalf.forEach(function (item) {
        listBodyA.appendChild(buildSpellRow(item));
      });

      if (!secondHalf.length) {
        addEmptyRow(listBodyB, "No additional spells.");
      } else {
        secondHalf.forEach(function (item) {
          listBodyB.appendChild(buildSpellRow(item));
        });
      }
    }

    function setDetailPlaceholders(message, title) {
      detailTitle.textContent = title !== undefined ? title : "Select a Spell";
      castTimeNode.textContent = "--";
      rangeNode.textContent = "--";
      durationNode.textContent = "--";
      attackSaveNode.textContent = "--";
      damageEffectNode.textContent = "--";
      materialNode.textContent = "";
      descriptionNode.textContent = message === undefined || message === null ? "Pick a spell to view details." : message;
      metaLevelNode.textContent = "--";
      metaSchoolNode.textContent = "--";
      metaSourceNode.textContent = "--";
      [componentVNode, componentSNode, componentMNode, componentCNode].forEach(function (icon) {
        icon.classList.remove("is-on");
      });
    }

    function formatLevel(levelValue) {
      const level = Number(levelValue);
      if (!Number.isFinite(level)) return "--";
      return level === 0 ? "Cantrip" : "Level " + level;
    }

    function renderDetail(detailData, fallbackName) {
      detailTitle.textContent = fallbackName || detailData.name || "Select a Spell";
      castTimeNode.textContent = detailData.castingTime || "--";
      rangeNode.textContent = detailData.rangeOrArea || "--";
      durationNode.textContent = detailData.duration || "--";
      attackSaveNode.textContent = detailData.attackOrSave || "--";
      damageEffectNode.textContent = detailData.damageOrEffect || "--";
      materialNode.textContent = detailData.materialText || "";
      descriptionNode.textContent = detailData.description || "No description available.";
      metaLevelNode.textContent = formatLevel(detailData.level);
      metaSchoolNode.textContent = detailData.school || "--";
      metaSourceNode.textContent = detailData.source || "--";

      componentVNode.classList.toggle("is-on", toBool(detailData.verbal));
      componentSNode.classList.toggle("is-on", toBool(detailData.somatic));
      componentMNode.classList.toggle("is-on", toBool(detailData.material));
      componentCNode.classList.toggle("is-on", toBool(detailData.concentration));
    }

    function loadSpellDetail(index) {
      if (isRolling) return;
      if (currentLevel === null || index < 0 || index >= currentSpells.length) return;
      const selectedSpell = currentSpells[index];
      if (!selectedSpell || selectedSpell.isReRoll) return;

      const detailIndex = Number(selectedSpell.detailIndex);
      if (!Number.isInteger(detailIndex) || detailIndex < 0) return;

      const fallbackName = selectedSpell.name ? selectedSpell.name : "Spell Details";
      selectedSpellIndex = index;
      renderSpellList();
      toggleDetailPanel(true);
      setDetailPlaceholders("", fallbackName);
      setDetailLoading(true);

      detailRequestToken += 1;
      const token = detailRequestToken;
      google.script.run
        .withSuccessHandler(function (rawData) {
          if (token !== detailRequestToken) return;
          let detailData;
          try {
            detailData = JSON.parse(rawData);
          } catch (error) {
            setDetailLoading(false);
            setDetailPlaceholders("Error loading spell detail.");
            return;
          }

          renderDetail(detailData || {}, fallbackName);
          setDetailLoading(false);
        })
        .withFailureHandler(function () {
          if (token !== detailRequestToken) return;
          setDetailLoading(false);
          setDetailPlaceholders("Error loading spell detail.");
        })
        .getSpellScrollDetail(currentLevel, detailIndex);
    }

    function clearSelectedSpell() {
      cancelRollSequence(false);
      detailRequestToken += 1;
      selectedSpellIndex = null;
      renderSpellList();
      toggleDetailPanel(false);
      setDetailLoading(false);
      setDetailPlaceholders("Pick a spell to view details.", " ");
    }

    function loadLevel(level) {
      cancelRollSequence(true);
      currentLevel = level;
      currentSpells = [];
      selectedSpellIndex = null;
      detailRequestToken += 1;

      setLevelSelection(level);
      toggleDetailPanel(false);
      setListLoading(true);
      setDetailLoading(false);
      filterInput.value = "";
      clearTBody(listBodyA);
      clearTBody(listBodyB);
      addEmptyRow(listBodyA, "Loading spells...");
      addEmptyRow(listBodyB, "Loading spells...");
      setDetailPlaceholders("Pick a spell to view details.", " ");

      listRequestToken += 1;
      const token = listRequestToken;

      google.script.run
        .withSuccessHandler(function (rawData) {
          if (token !== listRequestToken) return;
          let spellData;
          try {
            spellData = JSON.parse(rawData);
          } catch (error) {
            setListLoading(false);
            clearTBody(listBodyA);
            clearTBody(listBodyB);
            addEmptyRow(listBodyA, "Error loading spells.");
            addEmptyRow(listBodyB, "Error loading spells.");
            return;
          }

          currentSpells = normalizeSpellRows(spellData, level);
          renderSpellList();
          setListLoading(false);
        })
        .withFailureHandler(function () {
          if (token !== listRequestToken) return;
          setListLoading(false);
          clearTBody(listBodyA);
          clearTBody(listBodyB);
          addEmptyRow(listBodyA, "Error loading spells.");
          addEmptyRow(listBodyB, "Error loading spells.");
        })
        .fetchSpellScrollData(level);
    }

    function handleDocumentClick(event) {
      if (isRolling) return;
      if (!root || !root.classList.contains("spell-v2-has-detail")) return;
      if (event.target.closest("#spellV2DetailPanel")) return;
      if (event.target.closest("#spellV2FilterInput")) return;
      if (event.target.closest(".spell-v2-filter-label")) return;
      if (event.target.closest("#spellV2RollButton")) return;
      if (event.target.closest("tr[data-index]")) return;
      clearSelectedSpell();
    }

    function handleRootClick(event) {
      const rollTrigger = event.target.closest("#spellV2RollButton");
      if (rollTrigger && root.contains(rollTrigger)) {
        event.preventDefault();
        startRollSequence();
        return;
      }

      const levelButton = event.target.closest('[data-action="pick-level"]');
      if (levelButton && root.contains(levelButton)) {
        const level = Number(levelButton.getAttribute("data-level"));
        if (!Number.isNaN(level)) {
          loadLevel(level);
        }
      }
    }

    function handleTabChanged(event) {
      const nextTab = event && event.detail ? event.detail.tabName : "";
      if (nextTab !== "SpellScrollsV2") {
        cancelRollSequence(true);
      }
    }

    function initSpellV2() {
      root = document.getElementById("spellV2Root");
      if (!root) return;

      listBodyA = document.getElementById("spellV2ListBodyA");
      listBodyB = document.getElementById("spellV2ListBodyB");
      filterInput = document.getElementById("spellV2FilterInput");
      rollButton = document.getElementById("spellV2RollButton");
      rollValueNode = document.getElementById("spellV2RollValue");
      listLoadingNode = document.getElementById("spellV2ListLoading");
      detailLoadingNode = document.getElementById("spellV2DetailLoading");

      detailTitle = document.getElementById("spellV2DetailTitle");
      castTimeNode = document.getElementById("spellV2CastTime");
      rangeNode = document.getElementById("spellV2Range");
      durationNode = document.getElementById("spellV2Duration");
      attackSaveNode = document.getElementById("spellV2AttackSave");
      damageEffectNode = document.getElementById("spellV2DamageEffect");
      componentVNode = document.getElementById("spellV2CompV");
      componentSNode = document.getElementById("spellV2CompS");
      componentMNode = document.getElementById("spellV2CompM");
      componentCNode = document.getElementById("spellV2CompC");
      materialNode = document.getElementById("spellV2MaterialText");
      descriptionNode = document.getElementById("spellV2Description");
      metaLevelNode = document.getElementById("spellV2MetaLevel");
      metaSchoolNode = document.getElementById("spellV2MetaSchool");
      metaSourceNode = document.getElementById("spellV2MetaSource");

      root.addEventListener("click", handleRootClick);
      document.addEventListener("click", handleDocumentClick);
      document.addEventListener("app:tab-changed", handleTabChanged);
      filterInput.addEventListener("input", renderSpellList);
      updateRollValueDisplay(null);
      setDetailPlaceholders("Pick a spell to view details.", " ");
      loadLevel(0);
    }

    document.addEventListener("DOMContentLoaded", initSpellV2);
  })();
</script>
